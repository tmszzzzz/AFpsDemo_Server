### 这里记录一些开发中遇到的有价值的问题。

***

#18185e45  bugfix:kcc贴墙移动错误
- 表现：capsule从任何角度贴上一个box后，无法进行任何后续移动。
- 解析
  - 基础的判断流程：用三个球模拟capsule判断，使用这三个球分别与所有obb以位移 delta 求交，分别得到 t 值。t 值的含义是：此球在 delta 对应的方向上行进 t * delta，恰好与此obb产生碰撞。如果 t ∈ [0,1) ，那么这次位移就被认为产生了碰撞。取所有 t 值中最小的正值，就是此次迭代的最优碰撞。求解器将 [0,t) 区间的位移直接应用，然后 [t,1) 区间的位移先经过当前法线进行slide裁剪，然后进入下一次迭代。
  - 问题：capsule与任何box产生碰撞后，下一帧将产生一个 t = 0 的碰撞信息，它的含义是当前的capsule已经恰好贴在了某个box上，无需任何位移就已经产生了碰撞。然而，代码没有对 t = 0 给出碰撞信息，返回的碰撞法线总是Vec3.zero()，导致后续的计算无法进行。
    - 发现这个情况后，最自然的思路即是：把原本 t > 0 改为 >= ，尝试把判断准则延拓到 t = 0 上。这时 t = 0就能返回正常的法线信息了。然而，这个修改没有起到任何效果。
    - 打了个断点，尝试分析一下这个情况下离开墙壁的碰撞检测逻辑，发现离开墙壁时，离开墙壁的 delta 被法线裁剪掉了，因为这里有 t = 0 的碰撞，所以根据我们刚才的判断流程，整个 [t,1) 范围的剩余位移都要被拿去做slide，然后继续下次迭代。这就导致了这里的位移在法线上的分量明明是正值，却还是被裁剪掉了。
    - 错误的解决思路：发现这个问题后，我将slide的逻辑修改为：如果位移在法线上的分量是正值，就不裁剪掉法线上的分量。以此我期望在位移远离墙时可以正常具有向外的位移分量。经过试验，这个修改依然没有起到任何效果。继续打断点，终于发现问题如下：
      - capsule碰到墙壁，由于我们算法设计，此时center会严格地贴在box的边上。 
      - capsule尝试离开(或者做任何其他想要的位移)，第一轮迭代sweep时发现最好的（也就是 t 最小的）碰撞是一个 t = 0 的碰撞，应用特判，给出fallback的法线距离，并将这一次迭代产生的无碰撞位移应用上。然而，由于 bestHit 的 t = 0 ，这一次迭代没有产生任何有效位移，而remain的位移还是原位移。将remain位移应用slide，由于它与法线同向，所以不会产生剪切。于是remain位移还是原位移。 
      - 下一次迭代，由于上一轮的remain位移还是原位移，也没有应用任何无碰撞位移被应用，结果这次迭代的条件与上次完全相同，没有任何效果。 
      - 多次迭代直到超出迭代限制，每一次都没有任何效果。最终没有应用任何位移。 
      - 所以说，单纯的fallback法线根本不能解决问题，我们真正需要的也不是slide与法线通向的特判，而是我们需要在t=0时，通过对比当前delta的方向与fallback法线方向，决定是否“产生碰撞”！如果情况1：delta在法线方向上为正，那么将返回无碰撞的结果，这样我们才能进行下一个box的检测；如果情况2：为负，视这个box为一个碰撞，然后进行slide。特别地，如果情况3：为零，应该也视为无碰撞，因为情况2的下一次迭代将退化为情况3，如果视为碰撞，则又将产生不必要的重复迭代。